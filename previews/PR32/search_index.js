var documenterSearchIndex = {"docs":
[{"location":"interface/#A-new-Sampler","page":"A new Sampler","title":"A new Sampler","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"This guide aims to provide a tutorial on how to implement new sampler interfaces using Anneal.jl.","category":"page"},{"location":"interface/#The-@anew-macro","page":"A new Sampler","title":"The @anew macro","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Using the Anneal.@anew macro is the most straightforward way to get your sampler running right now. Apart from the macro call it is needed to implement the Anneal.sample method.","category":"page"},{"location":"interface/#I.-Imports","page":"A new Sampler","title":"I. Imports","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"First of all, we are going to import both Anneal.jl and also MathOptInterface.jl, commonly aliased as MOI.","category":"page"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"import Anneal\nimport MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"interface/#II.-@anew","page":"A new Sampler","title":"II. @anew","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"This macro takes two arguments: the identifier of the sampler's struct, and a begin...end block containing configuration parameters as key-value pairs. If ommited, the first defaults to Optimizer, following regular MOI conventions. In order to work smoothly, this approach leverages the QUBOTools backend.","category":"page"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"We expect that most users will be happy with this approach and it is likely that it will be improved and receive support very often.","category":"page"},{"location":"interface/#MathOptInterface-API-Coverage","page":"A new Sampler","title":"MathOptInterface API Coverage","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"This Document is intended to help keeping track of which MOI API Methods and Properties have been implemented for a new solver or model interface.","category":"page"},{"location":"interface/#Reference:","page":"A new Sampler","title":"Reference:","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"jump.dev/MathOptInterface.jl/stable/tutorials/implementing/","category":"page"},{"location":"interface/#Optimizer-Interface","page":"A new Sampler","title":"Optimizer Interface","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Method Status\nMOI.empty!(::Optimizer) ✅\nMOI.is_empty(::Optimizer)::Bool ✅\nMOI.optimize!(::Optimizer, ::MOI.ModelLike) ✅\nBase.show(::IO, ::Optimizer) ✔️","category":"page"},{"location":"interface/#The-copy_to-interface","page":"A new Sampler","title":"The copy_to interface","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Method Status\nMOI.copy_to(::Optimizer, ::MOI.ModelLike) ✅","category":"page"},{"location":"interface/#Constraint-Support","page":"A new Sampler","title":"Constraint Support","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Method Status\nMOI.supports_constraint(::Optimizer, ::F, ::S)::Bool where {F, S} ✔️","category":"page"},{"location":"interface/#Attributes","page":"A new Sampler","title":"Attributes","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Property Type get set supports\nMOI.SolverName String Ⓜ️ - -\nMOI.SolverVersion String Ⓜ️ - -\nMOI.RawSolver String ✔️ - -\nMOI.Name String Ⓜ️ Ⓜ️ Ⓜ️\nMOI.Silent Bool Ⓜ️ Ⓜ️ Ⓜ️\nMOI.TimeLimitSec Float64 Ⓜ️ Ⓜ️ Ⓜ️\nMOI.RawOptimizerAttribute Any Ⓜ️ Ⓜ️ Ⓜ️\nMOI.NumberOfThreads Int Ⓜ️ Ⓜ️ Ⓜ️","category":"page"},{"location":"interface/#Solution","page":"A new Sampler","title":"Solution","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Property Type get set supports\nMOI.PrimalStatus MOI.ResultStatusCode Ⓜ️ - -\nMOI.DualStatus MOI.ResultStatusCode Ⓜ️ - -\nMOI.RawStatusString String Ⓜ️ - -\nMOI.ResultCount Int Ⓜ️ - -\nMOI.TerminationStatus MOI.TerminationStatusCode Ⓜ️ - -\nMOI.ObjectiveValue T Ⓜ️ - -\nMOI.SolveTimeSec Float64 Ⓜ️ - -\nMOI.VariablePrimal T Ⓜ️ - -","category":"page"},{"location":"interface/#Warm-Start","page":"A new Sampler","title":"Warm Start","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Property Type get set supports\nMOI.VariablePrimalStart T Ⓜ️ Ⓜ️ Ⓜ️","category":"page"},{"location":"interface/#Key","page":"A new Sampler","title":"Key","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Symbol Meaning\nⓂ️ Implemented via the @anew macro\n✅ Available for Sampler{T}\n✔️ Available for AbstracSampler{T}\n⚠️ Must be implemented\n❌ Not implemented, but you can do it if you want to","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Solving-Simple-QUBO-Model-with-Anneal's-[ExactSampler](@ref-exact-sampler)","page":"Examples","title":"Solving Simple QUBO Model with Anneal's ExactSampler","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using JuMP\nusing Anneal\n\nmodel = Model(ExactSampler.Optimizer)\n\nQ = [\n    -1.0  2.0  2.0\n     2.0 -1.0  2.0\n     2.0  2.0 -1.0\n]\n\n@variable(model, x[1:3], Bin)\n@objective(model, Min, x' * Q * x)\n\noptimize!(model)\n\nfor i = 1:result_count(model)\n    xᵢ = value.(x; result=i)\n    yᵢ = objective_value(model; result=i)\n    println(\"f($xᵢ) = $yᵢ\")\nend","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Introduction","page":"Manual","title":"Introduction","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The core idea behind this package is to provide a toolbox for developing and integrating QUBO sampling tools with the JuMP mathematical programming environment. Appart from the few couple exported utility engines, Anneal.jl is inherently about extensions, which is achieved by implementing most of the MOI requirements, leaving only the essential for the developer.","category":"page"},{"location":"manual/#QUBO","page":"Manual","title":"QUBO","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"An optimization problem is in its QUBO form if it is written as","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"beginarrayrl\n           min  alpha left mathbfxmathbfQmathbfx + mathbfellmathbfx + beta right \n    textst  mathbfx in S cong mathbbB^n\nendarray","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"with linear terms mathbfell in mathbbR^n and quadratic mathbfQ in mathbbR^n times n. alpha beta in mathbbR are, respectively, the scaling and offset factors.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The MOI-JuMP optimizers defined using the Anneal.AbstractSampler{T} <: MOI.AbstractOptimizer interface only support models given in the QUBO form. Anneal.jl employs QUBOTools on many tasks involving data management and querying. It is worth taking a look at QUBOTool's docs.","category":"page"},{"location":"manual/#Defining-a-new-sampler-interface","page":"Manual","title":"Defining a new sampler interface","text":"","category":"section"},{"location":"manual/#Showcase","page":"Manual","title":"Showcase","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Before explaining in detail how to use this package, it's good to list a few examples for the reader to grasp. Below, there are links to the files where the actual interfaces are implemented, including thin wrappers, interfacing with Python and Julia implementations of common algorithms and heuristics.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Project Source Code\nDWaveNeal.jl DWaveNeal\nIsingSolvers.jl GreedyDescent\n ILP\n MCMCRandom\nQuantumAnnealingInterface.jl QuantumAnnealingInterface","category":"page"},{"location":"manual/#The-[@anew](@id-anew)-macro","page":"Manual","title":"The @anew macro","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Anneal.@anew is available to speed up the interface setup process. This mechanism was created to reach the majority of the target audience, that is, researchers interested in integrating their QUBO/Ising samplers in a common optimization ecossystem.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Anneal.@anew","category":"page"},{"location":"manual/#Anneal.@anew","page":"Manual","title":"Anneal.@anew","text":"@anew(expr)\n\nThe @anew macro receives a begin ... end block with an attribute definition on each of the block's statements.\n\nAll attributes must be presented as an assignment to the default value of that attribute. To create a MathOptInterface optimizer attribute, an identifier must be present on the left hand side. If a solver-specific, raw attribute is desired, its name must be given as a string, e.g. between double quotes. In the special case where an attribute could be accessed in both ways, the identifier must be followed by the parenthesised raw attribute string. In any case, the attribute type can be specified typing the type assertion operator :: followed by the type itself just before the equal sign.\n\nFor example, a list of the valid syntax variations for the number of reads attribute follows:     - \"num_reads\" = 1_000     - \"num_reads\"::Integer = 1_000     - NumberOfReads = 1_000     - NumberOfReads::Integer = 1_000     - NumberOfReads[\"num_reads\"] = 1_000     - NumberOfReads[\"num_reads\"]::Integer = 1_000\n\nExample\n\nAnneal.@anew Optimizer begin\n    name = \"Super Sampler\"\n    sense = :max\n    domain = :spin\n    version = v\"1.0.2\"\n    attributes = begin\n        NumberOfReads[\"num_reads]::Integer = 1_000\n        SuperAttribute[\"super_attr\"] = nothing\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"manual/","page":"Manual","title":"Manual","text":"Inside a module scope for the new interface, one should call the Anneal.@anew macro, specifying the solver's attributes as described in the macro's docs. The second and last step is to define the Anneal.sample(::Optimizer) method, that must return a Anneal.SampleSet.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Using it might be somehow restrictive in comparison to the regular JuMP/MOI Solver Interface workflow. Yet, our guess is that most of this package's users are not considering going deeper into the MOI internals that soon.","category":"page"},{"location":"manual/#[@anew](@ref-anew-macro)-example","page":"Manual","title":"@anew example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The following example is intended to illustrate the usage of the macro, showing how simple it should be to implement a wrapper for a sampler implemented in another language such as C or C++.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"module SuperSampler\n    using Anneal\n\n    Anneal.@anew Optimizer begin\n        name    = \"Super Sampler\"\n        sense   = :max\n        domain  = :spin\n        version = v\"1.0.2\"\n        attributes = begin\n            SuperAttribute::String = \"super\"\n            NumberOfReads[\"num_reads\"]::Integer = 1_000\n        end\n    end\n\n    model = Model(SuperSampler.Optimizer)\n\n    @variable(model, x[1:n], Bin)\n    @objective(model, Min, x' * Q * x)\n\n    function Anneal.sample(sampler::Optimizer{T}) where {T}\n        # ~ Is your annealer running on the Ising Model? Have this:\n        h, J, u, v = Anneal.ising(\n            Vector, # Here we opt for a sparse, vector representation\n            T,      # The coefficient type\n            sampler\n        )\n\n\n        n = MOI.get(sampler, MOI.NumberOfVariables())\n\n        # ~ Retrieve Attributes ~ #\n        num_reads = MOI.get(sampler, NumberOfReads())\n        @assert num_reads > 0\n\n        super_attr = MOI.get(sampler, SuperAttribute())\n        @assert super_attr ∈ (\"super\", \"ultra\", \"mega\")    \n\n        # ~*~ Timing Information ~*~ #\n        time_data = Dict{String,Any}()\n\n        # ~*~ Run Algorithm ~*~ #\n        result = @timed Vector{Int}[\n            super_sample(h, J, u, v; attr=super_attr)\n            for _ = 1:num_reads\n        ]\n        states = result.value\n\n        # ~*~ Record Time ~*~ #\n        time_data[\"effective\"] = result.time\n\n        metadata = Dict{String,Any}(\n            \"time\"   => time_data,\n            \"origin\" => \"Super Sampling method\"\n        )\n\n        # ~ Here some magic happens:\n        #   By providing the sampler and a vector of states,\n        #   Anneal.jl computes the energy and organizes your\n        #   solutions automatically, following the variable\n        #   domain conventions specified previously.\n        return Anneal.SampleSet{T}(sampler, states, metadata)\n    end\n\n    function super_sample(h, J, u, v; super_attr, kws...)\n        return ccall(\n            :super_sample,\n            Vector{Int},\n            (\n                Ptr{Cdouble},\n                Ptr{Cdouble},\n                Ptr{Cdouble},\n                Ptr{Cdouble},\n                Cint,\n                Cstring,\n            ),\n            h,\n            J,\n            u,\n            v,\n            super_attr,\n        )\n    end\nend","category":"page"},{"location":"manual/#Walkthrough","page":"Manual","title":"Walkthrough","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now, it's time to go through the example in greater detail. First of all, the entire work must be done within a module.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"module SuperSampler\n    using Anneal","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"By provding the using Anneal statement, very little will be dumped into the namespace apart from the MOI = MathOptInterface constant. MOI's methods will soon be very important to access our optimizer's attributes.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Anneal.@anew Optimizer begin\n    name    = \"Super Sampler\"\n    sense   = :max\n    domain  = :spin\n    version = v\"1.0.2\"\n    attributes = begin\n        SuperAttribute::String = \"super\"\n        NumberOfReads[\"num_reads\"]::Integer = 1_000\n    end\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The first parameter in the @anew call is the optimizer's identifier. It defaults to Optimizer and, in this case, is responsible for defining the Optimizer{T} <: MOI.AbstractOptimizer struct. A begin...end block comes next, with a few key-value pairs.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"info: Info\nOur solver, when deployed to be used within JuMP, will probably have its users to follow the usual construct:using JuMP\nusing SuperSampler\n\nmodel = Model(SuperSampler.Optimizer)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The solver name must be a string, and will be used as the return value for MOI.get(::Optimizer, ::MOI.SolverName()).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"name = \"Super Sampler\"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The sense and domain values indicate how our new solvers expect its models to be presented and, even more importantly, how the resulting samples should be interpreted. Their values must be either :min or :max and :boll or :spin, respectively. Strings, symbols and literals are supported as input for these fields.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"sense = :max\ndomain = :spin","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The other metadata entry is the version assignment, which is returned by MOI.get(::Optimizer, ::MOI.SolverVersion()). In order to consistently support semantic versioning it is required that the version number comes as a v-string e.g. v\"major.minor.patch\".","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"version = v\"1.0.2\"","category":"page"},{"location":"manual/#Model-Mapping","page":"Manual","title":"Model Mapping","text":"","category":"section"},{"location":"#Anneal.jl-Documentation","page":"Home","title":"Anneal.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims to provide a common MOI-compliant API for QUBO Sampling & Annealing machines. It also contains a few utility samplers and testing tools for performance comparison, sanity checks and basic analysis features.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Anneal.jl is registered in Julia's General Registry and is available for download using the standard package manager.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add Anneal","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"Anneal\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"You might also be interested in the latest development version:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add Anneal#master","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuMP\nusing Anneal\n\nmodel = Model(ExactSampler.Optimizer)\n\nQ = [\n    -1.0  2.0  2.0\n     2.0 -1.0  2.0\n     2.0  2.0 -1.0\n]\n\n@variable(model, x[1:3], Bin)\n@objective(model, Min, x' * Q * x)\n\noptimize!(model)\n\nfor i = 1:result_count(model)\n    xᵢ = value.(x; result=i)\n    yᵢ = objective_value(model; result=i)\n    rᵢ = reads(model; result=i)\n    println(\"f($xᵢ) = $yᵢ ($rᵢ)\")\nend","category":"page"},{"location":"#Citing-Anneal.jl","page":"Home","title":"Citing Anneal.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@software{anneal.jl:2022,\n  author = {Pedro Xavier and Tiago Andrade and Joaquim Garcia and David Bernal},\n  title        = {Anneal.jl},\n  month        = {sep},\n  year         = {2022},\n  publisher    = {Zenodo},\n  version      = {v0.4.2},\n  doi          = {10.5281/zenodo.6390515},\n  url          = {https://doi.org/10.5281/zenodo.6390515}\n}","category":"page"},{"location":"samplers/#Samplers","page":"Samplers","title":"Samplers","text":"","category":"section"},{"location":"samplers/#abstract-sampler","page":"Samplers","title":"Abstract Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Anneal.AbstractSampler","category":"page"},{"location":"samplers/#Anneal.AbstractSampler","page":"Samplers","title":"Anneal.AbstractSampler","text":"AbstractSampler{T} <: MOI.AbstractOptimizer\n\n\n\n\n\n","category":"type"},{"location":"samplers/#identity-sampler","page":"Samplers","title":"Identity Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Anneal.IdentitySampler","category":"page"},{"location":"samplers/#exact-sampler","page":"Samplers","title":"Exact Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Anneal.ExactSampler","category":"page"},{"location":"samplers/#random-sampler","page":"Samplers","title":"Random Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"Anneal.RandomSampler","category":"page"},{"location":"assets/README/#Anneal.jl's-Assets","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"","category":"section"},{"location":"assets/README/#logo","page":"Anneal.jl's Assets","title":"Logo","text":"","category":"section"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"Anneal.jl's logo aims to illustrate the annealing process with a progressive addition of the energy landscape.","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"(Image: Anneal.jl)","category":"page"},{"location":"assets/README/#Colors","page":"Anneal.jl's Assets","title":"Colors","text":"","category":"section"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"The colors were chosen according to  Julia's Reference for logo graphics¹. Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"assets/README/#Typography","page":"Anneal.jl's Assets","title":"Typography","text":"","category":"section"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"MADETYPE Sunflower² Font was used. It was converted to a SVG path through the Google Font to Svg Path³ online tool.","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"<a href=\"#1\">¹</a> github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"<a href=\"#2\">²</a> Licensed by the authors for use in this project","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"<a href=\"#3\">³</a> danmarshall.github.io/google-font-to-svg-path","category":"page"}]
}
