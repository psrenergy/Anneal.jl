var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Simple-QUBO","page":"Examples","title":"Simple QUBO","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using JuMP\nusing Anneal\n\nmodel = Model(SimulatedAnnealer.Optimizer)\n\nQ = [ 1.0  2.0 -3.0\n      2.0 -1.5 -2.0\n     -3.0 -2.0  0.5 ]\n\n@variable(model, x[i = 1:3], Bin)\n@objective(model, Min, x' * Q * x)\n\noptimize!(model)\n\nfor i = 1:result_count(model)\n      xi = value.(x; result = i)\n      yi = objective_value(model; result = i)\n      println(\"f($xi) = $yi\")\nend","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Introduction","page":"Manual","title":"Introduction","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The core idea behind this package is to provide a toolbox for developing and integrating QUBO annealing/sampling tools with the JuMP mathematical programming environment. Appart from the few couple bundled engines, Anneal.jl is inherently about extensions, which is achieved by implementing most of the MOI requirements, leaving only the essential for the developer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The annealers and samplers defined via the AbstractSampler{T} interface only support models given in a QUBO form, as explained below.","category":"page"},{"location":"manual/#QUBO","page":"Manual","title":"QUBO","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"An optimization problem is in its QUBO form if it is written as","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"beginarrayrl\n    min  mathbfx^intercal mathbfQ mathbfx + c \n    textst  mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"where mathbfQ in mathbbR^n is a symmetric matrix and c in mathbbR the constant offset.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In terms of Julia's data structures, we define a QUBO Normal Form (NQF) with a triplet","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(x::Dict{VI, Union{Int, Nothing}}, Q::Dict{Tuple{Int, Int}, T}, c::T)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"where x provides a mapping between each MathOptInterface's VariableIndex and the corresponding integer index in Q.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Even though only QUBO formulations are supported as input, Anneal provides internal tools for working with Ising Model instances since many samplers rely on it. Model validation and trivial QUBO/Insing conversion is made using the functions below.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Anneal.isqubo\nAnneal.qubo_normal_form\nAnneal.ising_normal_form","category":"page"},{"location":"manual/#Anneal.isqubo","page":"Manual","title":"Anneal.isqubo","text":"isqubo(model::MOI.ModelLike)\n\nTells if a given model is ready to be interpreted as a QUBO model.\n\nFor it to be true, a few conditions must be met:\n\nAll variables must be binary (MOI.VariableIndex ∈ MOI.ZeroOne)\nNo other constraints are allowed\nThe objective function must be of type MOI.ScalarQuadraticFunction, MOI.ScalarAffineFunction or MOI.VariableIndex\nThe objective sense must be either MOI.MIN_SENSE or MOI.MAX_SENSE\n\n\n\n\n\n","category":"function"},{"location":"manual/#Anneal.qubo_normal_form","page":"Manual","title":"Anneal.qubo_normal_form","text":"qubo_normal_form(model::MOI.ModelLike)\nqubo_normal_form(T::Type, model::MOI.ModelLike)\n\nReturns a triple (x Q c) where:\n\nx::Dict{MOI.VariableIndex, Union{Int, Nothing}} maps each of the model's variables to an integer index, to be used when interacting with Q.\nQ::Dict{Tuple{Int, Int}, T} is a sparse representation of the QUBO Matrix.\nc::T is the constant term associated with the problem.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Anneal.ising_normal_form","page":"Manual","title":"Anneal.ising_normal_form","text":"ising_normal_form(model::MOI.ModelLike)\nising_normal_form(T::Type, model::MOI.ModelLike)\nising_normal_form(x::Dict{VI, Union{Int, Nothing}}, Q::Dict{Tuple{Int, Int}, T}, c::T) where {T}\n\nReturns a quadruple (s h J c) where:\n\ns::Dict{MOI.VariableIndex, Union{Int, Nothing}} maps each of the model's variables to an integer index, to be used when interacting with h and J.\nh::Dict{Int, T} is a sparse vector for the linear terms of the Ising Model.\nJ::Dict{Tuple{Int, Int}, T} is a sparse representation of the quadratic magnetic interactions.\nc::T is the constant term associated with the problem.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Defining-a-new-sampler-interface","page":"Manual","title":"Defining a new sampler interface","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The Anneal.@anew macro is available to speed up the interface setup process.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Anneal.@anew","category":"page"},{"location":"manual/#Anneal.@anew","page":"Manual","title":"Anneal.@anew","text":"    @anew(expr)\n\nThe `@anew` macro receives a `begin ... end` block with an attribute definition on each of the block's statements.\n\nAll attributes must be presented as an assignment to the default value of that attribute. To create a MathOptInterface optimizer attribute, an identifier must be present on the left hand side. If a solver-specific, raw attribute is desired, its name must be given as a string, e.g. between double quotes. In the special case where an attribute could be accessed in both ways, the identifier must be followed by the parenthesised raw attribute string. In any case, the attribute type can be specified typing the type assertion operator `::` followed by the type itself just before the equal sign.\n\nFor example, a list of the valid syntax variations for the *number of reads* attribute follows:\n    - \"num_reads\" = 1_000\n    - \"num_reads\"::Integer = 1_000\n    - NumberOfReads = 1_000\n    - NumberOfReads::Integer = 1_000\n    - NumberOfReads(\"num_reads\") = 1_000\n    - NumberOfReads(\"num_reads\")::Integer = 1_000\n\n\n\n\n\n","category":"macro"},{"location":"manual/","page":"Manual","title":"Manual","text":"Inside a module scope for the new interface, one should call the Anneal.@anew macro, specifying the solver's attributes as described in the macro's docs. One must also define MOI.get methods for the MOI.SolverName, MOI.RawSolver and MOI.SolverVersion attributes. The last and most important step is to define the Anneal.sample method, which returns both a vector with every sample and also the sampling time. The whole standard definition is described in the next example.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"module SuperAnnealer\n    using Anneal\n\n    Anneal.@anew begin\n        NumberOfReads::Integer = 100\n        SuperAttribute::Any = nothing\n    end # This will define Optimizer{T} <: MOI.AbstractOptimizer\n\n    # -*- MathOptInterface -*-\n    function MOI.get(::Optimizer, MOI.SolverName)\n        \"Super Annealer\"\n    end\n\n    function MOI.get(::Optimizer, MOI.SolverVersion)\n        v\"0.1.0\" # Version strings are welcome!\n    end\n\n    function MOI.get(sampler::Optimizer, MOI.RawSolver)\n        # Usually the sampler itself, since we are prtty much low-level here.\n        # If you call another optimizer under the hood, you might want to return it.\n        sampler \n    end\n\n    function Anneal.sample(sampler::Optimizer)\n        # Is your annealer running on the Ising Model? Have this:\n        s, h, J, c = Anneal.ising_normal_form(sampler.x, sampler.Q, sampler.c)\n\n        n = MOI.get(sampler, NumberOfReads())\n        attr = MOI.get(sampler, SuperAttribute())\n\n        t0 = time()\n        results = [super_sample(h, J, attr) for i = 1:n]\n        t1 = time()\n\n        return (results, t1 - t0)\n    end\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Type assertion for Anneal.sample's return can be done using the ::Tuple{Anneal.SamplerResults, Float64} query.","category":"page"},{"location":"#Anneal.jl-Documentation","page":"Home","title":"Anneal.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims to provide a common MOI-compliant API for QUBO Sampling & Annealing machines. It also contains a few testing tools, including utility samplers for performance comparison and sanity checks, and some basic analysis features.","category":"page"},{"location":"#QUBO","page":"Home","title":"QUBO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Problems assigned to solvers defined within Anneal.jl's interface are given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayrl\ntextQUBO min  vecx Q vecx \n      textst  vecx in mathbbB^n\nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Q in mathbbR^n times n is a symmetric matrix. Maximization is automatically converted to minimization in a transparent fashion during runtime.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Anneal","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"Anneal\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuMP\nusing Anneal\n\nmodel = Model(SimulatedAnnealer.Optimizer)\n\nQ = [ 1.0  2.0 -3.0\n      2.0 -1.5 -2.0\n     -3.0 -2.0  0.5 ]\n\n@variable(model, x[i = 1:3], Bin)\n@objective(model, Min, x' * Q * x)\n\noptimize!(model)\n\nfor i = 1:result_count(model)\n    xᵢ = value.(x; result=i)\n    yᵢ = objective_value(model; result=i)\n    println(\"f($xᵢ) = $yᵢ\")\nend","category":"page"},{"location":"#Supported-Annealers-and-Samplers","page":"Home","title":"Supported Annealers & Samplers","text":"","category":"section"},{"location":"#Annealing-Wrappers","page":"Home","title":"Annealing Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Module Name Descripition Package Status\nSimulatedAnnealer Wrapper around D-Wave Neal simulated annealing Python package. Anneal.jl ✔️","category":"page"},{"location":"#Utility-Samplers","page":"Home","title":"Utility Samplers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Module Name Descripition Package Status\nExactSampler Sequentially samples all possible states by exaustive enumeration. Finds the global optimum but can't be used for models with much more than 20 variables. Anneal.jl ✔️\nRandomSampler Randomly samples states by regular or biased coin tossing. It is commonly used to compare new solving methods to a random guessing baseline. Anneal.jl ✔️\nIdentitySampler Samples the exact same state defined as warm start. Anneal.jl ✔️","category":"page"},{"location":"#Citing-Anneal.jl","page":"Home","title":"Citing Anneal.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@software{anneal.jl:2022,\n  author = {Pedro Xavier and Tiago Andrade and Joaquim Garcia and David Bernal},\n  title        = {Anneal.jl},\n  month        = {mar},\n  year         = {2022},\n  publisher    = {Zenodo},\n  version      = {v0.1.1},\n  doi          = {10.5281/zenodo.6390515},\n  url          = {https://doi.org/10.5281/zenodo.6390515}\n}","category":"page"},{"location":"assets/README/#Anneal.jl's-Assets","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"","category":"section"},{"location":"assets/README/#Logo","page":"Anneal.jl's Assets","title":"Logo","text":"","category":"section"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"Anneal's logo aims to illustrate the annealing process with a progressive addition of the energy landscape.","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"(Image: ToQUBO.jl)","category":"page"},{"location":"assets/README/#Colors","page":"Anneal.jl's Assets","title":"Colors","text":"","category":"section"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"The colors were chosen according to  Julia's Reference for logo graphics¹. Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"assets/README/#Typography","page":"Anneal.jl's Assets","title":"Typography","text":"","category":"section"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"MADETYPE Sunflower² Font was used. It was converted to a SVG path through the Google Font to Svg Path³ online tool.","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"<a href=\"#1\">¹</a> github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"<a href=\"#2\">²</a> Licensed by the authors for use in this project","category":"page"},{"location":"assets/README/","page":"Anneal.jl's Assets","title":"Anneal.jl's Assets","text":"<a href=\"#3\">³</a> danmarshall.github.io/google-font-to-svg-path","category":"page"}]
}
